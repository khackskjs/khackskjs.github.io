{"meta":{"title":"sVeloper's","subtitle":"철인 뛰는 개발자","description":"그대여, 너무 걱정하지 말아요. 지나간 것은 지나간대로 그런 의미가 있죠","author":"Robert Kim","url":"http://khackskjs.github.io"},"pages":[],"posts":[{"title":"Could Would 사용하기","slug":"English-Youtube-LiveAcademy-Could-Would","date":"2018-01-03T13:10:59.000Z","updated":"2018-01-03T14:08:37.000Z","comments":true,"path":"2018/01/03/English-Youtube-LiveAcademy-Could-Would/","link":"","permalink":"http://khackskjs.github.io/2018/01/03/English-Youtube-LiveAcademy-Could-Would/","excerpt":"","text":"Would/Could 올바르게 사용하기Youtube의 would와 could 올바르게 이해하고 자연스럽게 사용하기를 기억하기 위해 정리한 내용입니다. Sumary 과거형 동사와 함께 사용 단독으로 사용 의미 과거의 시점에서 미래에 대한 얘기 현재와 미래에 대한 얘기 Could I thought I could make it I could make it but… Would he told me he would get here on time I would help me, if I were you 몸풀기 I couldn’t get up early yesterday I could get up early yesterday. 위의 두 문장 중 2번 문장은 어색하다. Could/Would의 정체Could/Would의 정체는 무엇일까? Can/Will의 과거일까? 시제는 동사에 적용한다. Can/Could/Will/Would는 조동사이다. 따라서 Could/Would는 Can/Will의 과거가 아니다! 그럼 흔히 생각하는 ~할 수 있었어 라는 표현을 알아보자. was able to: I was able to get up early yesterday. managed to: I managed to get up early yesterday. 할수있다/할것이다의 과거형은 위와같이 표현하면 된다. Usage 1. 과거와 함께 사용과거 시점에서 바라보는 미래를 표현 함 I thought It would rain today: 나는 오늘 비가 올 줄 알았어. &lt;- 과거시점(thought)에서 바라보는 미래(today)She promised (that) she wouldn’t talk about that again.I told him (that) I would try my best.They told me they would give an answer by this friday.I thought this would be more expensive.I thought you could help me.I didn’t think I could get here on time.She knew she could pass the test. 과거 vs would 비교아래 2가지의 차이가 무엇일까? I thought you would know about that I thought you knew about that 해석을 하면 다음과 같다. 나는 니가 그것에 대해 알 줄 알았어. 나는 니가 그걸 알고 있는줄 알았어. (= I thought you already knew about that) 즉 1번은 알고 있는지 모르는지에 대한 불확실함을 내포하고, 2번은 이미 알고 있다고 생각을 한것. 영어 vs 한국어 비교국어에서는 톤강조를 통해 표현한다. 나는 제 시간에 못할 줄 알았어 나는 제 시간에 못할 줄 알았어 대응되는 영어는 다음과 같다. I didn’t think I could make it on time. I knew I couldn’t make it on time. Usage 2. 단독으로 사용It’s uncertain version of Can/Will (~을 (할) 수도 있다.) I could marry her, but I think I need to think about it some more. 현재 혹은 미래의 불확실함을 표현 -&gt; 가정(if)하에 생각하면 확실할 수 있는게 없다.따라서 불확실함을 표현하기에 if와 함께 사용하는 경우가 많다. if you were my friend, I would help you","categories":[],"tags":[{"name":"English","slug":"English","permalink":"http://khackskjs.github.io/tags/English/"}]},{"title":"Angular - egghead 01","slug":"Angular-egghead-01","date":"2017-11-27T15:18:40.000Z","updated":"2017-12-10T12:50:48.000Z","comments":true,"path":"2017/11/28/Angular-egghead-01/","link":"","permalink":"http://khackskjs.github.io/2017/11/28/Angular-egghead-01/","excerpt":"","text":"[Egg Head] Angular Get StartedEgg Head의 Get Started with Angular를 강의 순서대로 남겨 둘만한 부분에 대해서 간단히 정리 해 본다. 2. Create a Simple Angular 2 Component123$ ng generate component simple-form --inline-template --inline-style# same as$ ng g c simple-form -it -is .angular-cli.json file 에 apps.prefix 값이 selecotr의 prefix로 동작 함 3. Manage Angular 2 Elements with Events and Refsclick event &amp; input bindinginput 으로부터 값을 입력 받아서, click 하면 출력하는 예제를 통해 event binding을 해 본다. ./src/app/simple-form/simple-form.component.ts12345678910111213@Component(&#123; template: ` &lt;div&gt; &lt;input #myInput type=\"text\"&gt; &lt;button (click)=\"onClick(myInput.value)\"&gt; &lt;/div&gt; `&#125;)export class SimpleFormComponent implements OnInit &#123; onClick(value) &#123; console.log('clicked', value); &#125;&#125; DOM event(click)를 onClick method 와 binding. #myInput 은 refs 라고 하며, Element를 가리키는 듯. #myInput 의 정체를 조금 더 알 핖요가 있을 듯 HTML에서 onClick(myInput)으로 value가 아닌 myInput을 전달하게 되면 Element 가 전달된다. console.log(myInput.value) 한 후 CDT &gt; console의 출력에 마우스 오버하면 해당 Element를 하이라이트 해 준다. 4. Control Angular 2 Events with $event and Event Handlers$event를 parameter 로 넘길 수 있다. 1234567891011@Component(&#123; template: `&lt;div&gt; &lt;input #myInput type=\"text\"&gt; &lt;button (click)=\"onClick($event, myInput.value)\"&gt;BTN&lt;/button&gt; &lt;/div&gt;`&#125;)export class SimpleFormComponent implements OnInit &#123; onClick(event, value) &#123; console.log(event, value); &#125;&#125; 5. Share Services and Data with Angular 2 Dependency Injection app.module.ts의 providers에 생성한 Service Class 추가 ex) providers: [MailService] 사용할 Component의 constructor에 추가 ex) constructor(private mailService: MailService) {} 6. Provide and Share Values with Angular 2 Dependency Injectionproviders에 object를 통해 이름을 변경해서 DI 해 본다. app.module.ts의 providers에 {provide: &#39;이름&#39;, useClass: 서비스_클래스} 또는 {provide: &#39;이름&#39;, useValue: &#39;값&#39;}형태로 주입 ex) { provide: &#39;mail&#39;, useClass: MailService }ex) { provide: &#39;name&#39;, useValue: &#39;robert kim&#39; } 사용할 Component의 constructor에 @Inject 데코레이터와 함께 사용 ex) constructor(@Inject(&#39;mail&#39;) private mail, @Inject(&#39;name&#39;) private name) 7. Loop Through Angular 2 Components with ngForngFor 를 사용 해 본다. HTML에서 *ngFor=&quot;let {변수} of {참조}&quot; 형태로 사용 12345&lt;ul&gt; &lt;li *ngFor=\"let message of mail.messages\"&gt; &#123;&#123; message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; Angular Compiler는 HTML을 컴파일 하면서 *가 있는 부분은 다시 재생성 하는걸로 보인다. 8. Pass Values into Angular 2 Components with @InputComponent 값을 주입하기 위해서는 attribute 형태로 주입하며, @Input을 이용해야 한다. 123456789101112import &#123; Component, OnInit, Input &#125; from '@angular/core';@Component(&#123; selector: `di-test`, template: `&#123;&#123; diMessage &#125;&#125;`&#125;)class DITestComponent implements OnInit &#123; @Input() diMessage; constructor() &#123;&#125; ngOnInit() &#123;&#125;&#125; line 1: Input decorator는 @angular/core를 사용한다. line 5: diMessage를 interpolation 했다는건, 해당 class의 member 변수라는 의미 일 것이다. line 8: diMessage에 @Input decorator 를 붙이므로, Attribute를 통해 값을 받을 수 있다. 위의 DITestComponent는 아래와 같이 사용하면 된다. 1`&lt;di-test [message]=\"some message\"&gt;&lt;/di-test&gt; 9. Sync Values from Inputs with Angular 2’s ngModel Two-Way Binding2-way Binding에 대해 알아본다. 사용법은 HTML에 [(ngModel)]=variable 형태로 ngModel keyword를 통해 변수와 바인딩 한다. app.module.ts에 FormsModule를 imports 해야 한다. 10. Pass Events from Angular 2 Components with @Output","categories":[{"name":"angular","slug":"angular","permalink":"http://khackskjs.github.io/categories/angular/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://khackskjs.github.io/tags/angular/"},{"name":"egghead","slug":"egghead","permalink":"http://khackskjs.github.io/tags/egghead/"}]},{"title":"normalize example","slug":"normalize-example","date":"2017-11-25T22:43:12.000Z","updated":"2017-12-03T15:03:37.000Z","comments":true,"path":"2017/11/26/normalize-example/","link":"","permalink":"http://khackskjs.github.io/2017/11/26/normalize-example/","excerpt":"","text":"Normalizrnarmalizr 사용법을 익혀 본다. 목차 Normalizr 목차 Definition Motivation Solution Execution of normalizr Environment Project init babel &amp; normalizr setting Coding Run Result Into the Normalizr normalize function example of normalize function Dive into the normalizr references Definitionnormalize: 표준화/일반화 하다. 어디선가 본 가장 와닿는 정의는 다음과 같다. : a way of cleaning up JSON data consisting of many deeply nested objects 깊게 중첩된 오브젝트로 구성된 JSON 데이터를 정리하는 방법 normalizr란 Motivation과 Solution을 살펴보면 알 수 있듯이, 복잡한 JSON Object를 정규화 하기 위한 Library 정도 되겠다. MotivationMany APIs, public or not, return JSON data that has deeply nested objects. Using data in this kind of structure is often very difficult for JavaScript applications, especially those using Flux or Redux. 많은 API들은 중첩된 객체 형태의 JSON을 return 한다. 이런 구조의 데이터를 사용하는 것은 javascript applications, 특히 Flux 또는 Redux를 사용 하기 어렵다. SolutionNormalizr is a small, but powerful utility for taking JSON with a schema definition and returning nested entities with their IDs, gathered in dictionaries. Normalizr은 JSON을 스키마 정의로 사용하고, Dictionary에 저장된 ID로 중첩 된 항목을 반환하는 작지만 강력한 유틸리티. Execution of normalizr이론을 글로 읽는 것 보다는 실행 전/후를 살펴보는게 훨씬 빠르게 이해 할 수 있을 것이다. ㄱㄱㅆ normalizr (github, paularmstrong) 예제를 테스트하기 편하게 재작성 해 보았다. EnvironmentECMAScript Module(ESM)을 사용하고 있어, node.js 는 기본적으로 CommonJS Module loading을 사용하기 때문에 babel을 사용해서 실행한다.node.js v8.9.1의 –experimental-modules flag 사용을 해 보려고 했으나, 결국 실패해서 포스팅 재작성 Project init1234&gt; mkdir normalizr_khackskjs&gt; cd normalizr_khackskjs&gt; npm init -y&gt; npm i --save normalizr babel &amp; normalizr setting@babel/node를 통해서 ESM을 tranpile과 동시에 실행하도록 한다. babel-cli를 설치 @babel/core, @babel/node 설치 transpile presets 설치 normalizr module 설치 1234&gt; npm i -g babel-cli&gt; npm i --save-dev @babel/core @babel/node&gt; npm i --save-dev babel-preset-es2015 babel-preset-stage-1&gt; npm i --save normalizr .babelrc file을 생성 한 후 tranpile 시 preset options을 지정한다. ./.babelrc123&#123; \"presets\": [\"es2015\", \"stage-1\"]&#125; Codinginput.json 파일을 읽어서, normalize 한 후 output.json file에 쓰는 예제이다. 아래 input.json, schema.js, input.js source를 그대로 붙여넣어 파일을 생성한다. ./input.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[&#123; \"id\": \"1\", \"title\": \"My first post!\", \"author\": &#123; \"id\": \"123\", \"name\": \"Paul\" &#125;, \"comments\": [&#123; \"id\": \"249\", \"content\": \"Nice post!\", \"commenter\": &#123; \"id\": \"245\", \"name\": \"Jane\" &#125; &#125;, &#123; \"id\": \"250\", \"content\": \"Thanks!\", \"commenter\": &#123; \"id\": \"123\", \"name\": \"Paul\" &#125; &#125; ] &#125;, &#123; \"id\": \"2\", \"title\": \"This other post\", \"author\": &#123; \"id\": \"123\", \"name\": \"Paul\" &#125;, \"comments\": [&#123; \"id\": \"251\", \"content\": \"Your other post was nicer\", \"commenter\": &#123; \"id\": \"245\", \"name\": \"Jane\" &#125; &#125;, &#123; \"id\": \"252\", \"content\": \"I am a spammer!\", \"commenter\": &#123; \"id\": \"246\", \"name\": \"Spambot5000\" &#125; &#125; ] &#125;] ./schema.js1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; schema &#125; from 'normalizr';const userProcessStrategy = (value, parent, key) =&gt; &#123; switch (key) &#123; case 'author': return &#123; ...value, posts: [ parent.id ] &#125;; case 'commenter': return &#123; ...value, comments: [ parent.id ] &#125;; default: return &#123; ...value &#125;; &#125;&#125;;const userMergeStrategy = (entityA, entityB) =&gt; &#123; return &#123; ...entityA, ...entityB, posts: [ ...(entityA.posts || []), ...(entityB.posts || []) ], comments: [ ...(entityA.comments || []), ...(entityB.comments || []) ] &#125;;&#125;;const user = new schema.Entity('users', &#123;&#125;, &#123; mergeStrategy: userMergeStrategy, processStrategy: userProcessStrategy&#125;);const comment = new schema.Entity('comments', &#123; commenter: user&#125;, &#123; processStrategy: (value, parent, key) =&gt; &#123; return &#123; ...value, post: parent.id &#125;; &#125;&#125;);const post = new schema.Entity('posts', &#123; author: user, comments: [ comment ]&#125;);export default [ post ]; ./index.js1234567891011import input from './input.json';import fs from 'fs';import &#123; normalize &#125; from 'normalizr';import path from 'path';import postsSchema from './schema';const normalizedData = normalize(input, postsSchema);const output = JSON.stringify(normalizedData, null, 2);fs.writeFileSync(path.resolve(__dirname, './output.json'), output);console.log('./output.json has been created'); Run1&gt; babel-node index.js Resultoutput.json 파일이 생성되며, 결과는 다음과 같다. ./output.json1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#123; \"entities\": &#123; \"users\": &#123; \"123\": &#123; \"id\": \"123\", \"name\": \"Paul\", \"posts\": [ \"1\", \"2\" ], \"comments\": [ \"250\" ] &#125;, \"245\": &#123; \"id\": \"245\", \"name\": \"Jane\", \"comments\": [ \"249\", \"251\" ], \"posts\": [] &#125;, \"246\": &#123; \"id\": \"246\", \"name\": \"Spambot5000\", \"comments\": [ \"252\" ] &#125; &#125;, \"comments\": &#123; \"249\": &#123; \"id\": \"249\", \"content\": \"Nice post!\", \"commenter\": \"245\", \"post\": \"1\" &#125;, \"250\": &#123; \"id\": \"250\", \"content\": \"Thanks!\", \"commenter\": \"123\", \"post\": \"1\" &#125;, \"251\": &#123; \"id\": \"251\", \"content\": \"Your other post was nicer\", \"commenter\": \"245\", \"post\": \"2\" &#125;, \"252\": &#123; \"id\": \"252\", \"content\": \"I am a spammer!\", \"commenter\": \"246\", \"post\": \"2\" &#125; &#125;, \"posts\": &#123; \"1\": &#123; \"id\": \"1\", \"title\": \"My first post!\", \"author\": \"123\", \"comments\": [ \"249\", \"250\" ] &#125;, \"2\": &#123; \"id\": \"2\", \"title\": \"This other post\", \"author\": \"123\", \"comments\": [ \"251\", \"252\" ] &#125; &#125; &#125;, \"result\": [ \"1\", \"2\" ]&#125; Into the Normalizrnormalizr interface 부분을 간략히 살펴본 후 예제를 통해서 사용법을 익혀본다. 1234567891011121314declare namespace schema &#123; // 중략&#125;export type Schema = schema.Array | schema.Entity | schema.Object | schema.Union | schema.Values | schema.Array[] | schema.Entity[] | schema.Object[] | schema.Union[] | schema.Values[] | &#123;[key: string]: Schema&#125;;export function normalize(data: any, schema: Schema) : &#123; entities: any, result: any &#125;;export function denormalize(input: any, schema: Schema, entities: any) : any; normalize functionnormalize(data: any, schema: Schema): { entities: any, result: any } Normalizes input data per the schema definition provided. data: required Input JSON (or plain JS object) data that needs normalization. schema: required A schema definition GitHub에서 normalize function을 위와같이 설명하고 있다. 그렇다고 한다-ㅅ- normalize function을 사용하기 위해서는 normalize 할 원본 데이터(JSON or plain JS object)와, 해당 원본 데이터의 schema를 정의한 Scmhema를 parameter로 전달해야 한다. export type Schema =를 이루는 항목들을 보면 알 수 있듯 Schema는 모두 namespace schema를 이용해서 만들어야 한다.그리고 보통 schema.Entity, schema.Array 그리고 {[key: string]: Schema}를 사용 할 것으로 보인다. 무슨 말인고 하니, input data가 어떻게 이루어져 있는지를 정의하고, 필요에 따라서는 몇가지 옵션을 통해서 Entity를 만져주면 된다. example of normalize functioninput data의 구조를 분해해서 Entity, Schema 를 작성하면 된다. demo/01.js1234567import &#123; normalize, schema &#125; from 'normalizr';const input = &#123; books: [&#123; id: 1, title: 'rework' &#125;, &#123; id: 2, title: '대한민국이 묻는다'&#125;] &#125;, book = new schema.Entity('book'), bookSchema = &#123; books: [book] &#125;, normalized = normalize(input, bookSchema);console.log(require('util').inspect(normalized, &#123; depth: null &#125;)); 우리의 관심사는 book 이라는 Entity에 들어있는 값 들이다.하지만 input data에 book은 books 라는 property에 Array 형태로 존재한다.따라서 이를 정리하면 다음과 같다. input data 는 object 형태로 books라는 property에 Array를 가지고 있다. input = { books: [] } 이 Array의 item은 object이며, 이를 book 으로 사용 하도록 한다. book = { id: 1, title: &#39;rework&#39; } 위의 순서에 따라서 정의(line 3, 4) 한 후, normalize function에 전달하면 된다. 결과는 아래와 같다. 12345&#123; entities: &#123; book: &#123; '1': &#123; id: 1, title: 'rework' &#125;, '2': &#123; id: 2, title: '대한민국이 묻는다' &#125; &#125; &#125;, result: &#123; books: [ 1, 2 ] &#125; &#125; 아주 심플한 예제는 이정도에서 마치자. Dive into the normalizr앞서 최초 실행 해 봤던 예제에 대한 분석. To be continue.. processStrategy(value, parent, key): Strategy to use when pre-processing the entity. Use this method to add extra data, defaults, and/or completely change the entity before normalization is complete. Defaults to returning a shallow copy of the input entity. Note: It is recommended to always return a copy of your input and not modify the original. The function accepts the following arguments, in order: value: The input value of the entity. parent: The parent object of the input array. key: The key at which the input array appears on the parent object. referencespaularmstrong/normalizr (github)","categories":[],"tags":[{"name":"babel-node","slug":"babel-node","permalink":"http://khackskjs.github.io/tags/babel-node/"},{"name":"babel","slug":"babel","permalink":"http://khackskjs.github.io/tags/babel/"},{"name":"normalizr","slug":"normalizr","permalink":"http://khackskjs.github.io/tags/normalizr/"}]},{"title":"Angular Restaurant Demo App(Routing, Http)","slug":"Angular-Restaurant-Demo-App-Routing-Http","date":"2017-09-02T12:29:40.000Z","updated":"2017-09-16T16:15:50.000Z","comments":true,"path":"2017/09/02/Angular-Restaurant-Demo-App-Routing-Http/","link":"","permalink":"http://khackskjs.github.io/2017/09/02/Angular-Restaurant-Demo-App-Routing-Http/","excerpt":"","text":"Routing과 Http Module을 이용해서 Restaurant App을 만들어 보도록 하자. 사람마다 배우는 스타일이 다를거라고 생각한다. (개인적으로 나는 이론적인 부분을 깊에 파고 들어서 이해를 해야 직성이 풀리는 스타일이다)하지만 개발자라면 대부분 코딩 실습을 통해 본인이 해보지 않으면 안다고 or 공부했다고 생각한게 제대로 한게 아니라는건 동의 하지 않을까 추측해 본다. 이에 Angular의 Routing, Http 를 학습 한 김에 간단한 App을 제작 해 보기로 한다. Angular Routing, Http 실습: Restaurant AppAppApp은 3개의 탭으로 구성되어 있다. Home, Menu Category, About Us각각의 탭은 Route로 구현한다. Menu Category 탭에서 메뉴 종류를 선택한 후 메뉴 상세를 볼 수 있다.Menu Category List 및 메뉴 상세는 HTTP를 통해 정적 데이터를 로드한 후 보여준다. Angular를 얕게 공부 한 후 처음으로 만들어 보기 딱 좋은 App 이라 생각한다. 구조 생성Project 생성12345$ ng new RestaurantDemoAppinstalling ng ...Project 'RestaurantDemoApp' successfully created.$ code ./RestaurantDemoApp Component 생성123$ ng g component Home$ ng g component AboutUs$ ng g component MenuCategory src/app/아래에 about-us, home, menu-category folder가 생긴것을 확인 할 수 있다.src/app/app.module.ts를 확인 해 보면 아래와 같은 내용이 추가 된 것을 확인 할 수 있다. 1234567891011import &#123; AboutUsComponent &#125; from './about-us/about-us.component';import &#123; HomeComponent &#125; from './home/home.component';import &#123; MenuCategoryComponent &#125; from './menu-category/menu-category.component';@NgModule(&#123; declarations: [ AppComponent, AboutUsComponent, HomeComponent, MenuCategoryComponent, ], RouterRouter Module App에 추가app.module.ts123456789101112import &#123; RouterModule, Routes &#125; from \"@angular/router\";const restaurantRoutes: Routes = [ &#123; path: 'home', component: HomeComponent &#125;, &#123; path: 'aboutUs', component: AboutUsComponent &#125;, &#123; path: 'menu-category', component: MenuCategoryComponent &#125;];@NgModule(&#123; imports: [ RouterModule.forRoot(restaurantRoutes) ] 1 Line: Router를 사용하기 위한 모듈들을 import3~7 Lines: Restaurant App에서 사용할 route path와 그에따른 component 지정12 Line: Router를 생성하는 public static method를 이용해서 Router를 생성한다. 이제 우리 앱에서 라우터를 사용 할 수 있다. 간단히 Text 형태로 Routing 을 구현하도록 하겠다. Navigation 만들기app.component.html123456&lt;div&gt;&lt;a [routerLink]=\"['/home']\"&gt;HOME&lt;/a&gt;&lt;a [routerLink]=\"['/menu-category']\"&gt;MENU CATEGORY&lt;/a&gt;&lt;a [routerLink]=\"['/aboutUs']\"&gt;ABOUT US&lt;/a&gt;&lt;/div&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; ng new {project name}에 의해 생성되는 기본 Component인 app.component의 기존 코드는 모두 제거하고, 위의 코드를 넣는다. 2 Line: one-time binding을 위해 []로 감싼 [routerLink]에 RouterModule.forRoot()에 파라미터로 전달한 주소중 하나인 home을 넘긴다.routerLink에 할당하는 값은 string Array이다. (2번째 인자값은 parameter) Home, MenuCategory, AboutUs는 ng를 이용해 Component를 만들었기 때문에, 각 Component.html 파일에 &lt;p&gt;about-us works!&lt;/p&gt; 다음과 같이 작성이 되어 있다. 이제 실행을 시킨 후 웹 브라우저로 확인하면 Routing 된 페이지를 확인 할 수 있다. 1234$ ng serve** NG Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200 **#(중략)webpack: Compiled successfully. HTTPHTTP Module 사용은 조금 더 복잡한 면이 있어서, 이번 예제에서는 Data Model 객체는 사용하지 않는다. HTTP Module App에 추가app.module.ts123456import &#123; HttpModule, Http &#125; from \"@angular/http\";@NgModule(&#123; imports: [ HttpModule ] Service 만들기HTTP를 사용해서 Data를 처리할 Service를 만들고, NgModule.providers에 등록한다. src/app/menu-category/menu-category.service.ts1234567891011121314151617import &#123; Injectable &#125; from \"@angular/core\";import &#123; Http &#125; from \"@angular/http\";import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/add/operator/map';const CATEGORY_MENU_URL = \"https://khackskjs-course5.herokuapp.com/categories.json\";@Injectable()export class CategoryService &#123; constructor(private http: Http) &#123;&#125; getCategories(): Observable&lt;any&gt; &#123; return this.http.get(CATEGORY_MENU_URL) .map(response =&gt; response.json()); &#125;&#125; src/app/app.module.ts12345import &#123; CategoryService &#125; from './menu-category/menu-category.service';@NgModule(&#123; providers: [CategoryService]&#125;) Component 만들기Data를 가져오는 Service를 만들었다면, 이제 Service를 사용하는 Component를 만든다. 1ng g component menuCategory src/app/menu-category/menu-category.component.ts12345678910111213141516171819import &#123; Component, OnInit &#125; from '@angular/core';import &#123; CategoryService &#125; from \"./menu-category.service\";@Component(&#123; selector: 'app-menu-category', templateUrl: './menu-category.component.html', styleUrls: ['./menu-category.component.css']&#125;)export class MenuCategoryComponent implements OnInit &#123; categoryList: any[]; constructor(private categoryService: CategoryService) &#123;&#125; ngOnInit() &#123; this.categoryService.getCategories() .subscribe(res =&gt; &#123; this.categoryList = res; &#125;); &#125;&#125; src/app/menu-category/menu-category.component.html123456789101112&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;Category Name&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr *ngFor=\"let category of categoryList\"&gt; &lt;td&gt; &#123;&#123; category.name &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 정리Router와 Http를 사용해서 간단한 web App을 구현 해 봤다. Router와 Http를 사용하기 위해서 어떤 일련의 과정을 해야 하는지를 중점적으로 보기 바란다.","categories":[],"tags":[]},{"title":"Angular Get Started","slug":"Angular-Get-Started","date":"2017-08-25T20:12:34.000Z","updated":"2017-08-27T14:06:30.000Z","comments":true,"path":"2017/08/26/Angular-Get-Started/","link":"","permalink":"http://khackskjs.github.io/2017/08/26/Angular-Get-Started/","excerpt":"","text":"Angular Get Started(angular/cli)Angular.js는 이름 그대로 javascript전용 framework이다. version 2로 업그레이드 하면서 이름을 Angular로 명명했다. js를 떼어냈다는 의미는 javascript전용은 아니라는 의미로 받아들이면 되며, typescript를 사용 할 것을 권장한다. typescript 를 사용해서 결국은 javascript로 tranpiling 한다. angular/cliAngular에서는 angular/cli 라는 CLI Tool을 지원하고 있다.요즘 대부분의 웹 관련 모듈들이 그러하듯 npm( 참조)을 통해서 설치할 수 있다. 우선 typescript를 설치한다. 1npm i -g typescript 그 후 angular/cli를 설치한다. Old versionangular/cli 가 @angular/cli package로 통합되었다.npm list -g angular-cli 통해 구버전 angular-cli가 설치되어 있을 경우, 업데이트 가이드를 따르기 바란다. 1&gt; npm i -g @angular/cli angular/cli가 설치되며, CLI에서 ng 명령어를 통해 여러가지 코드를 자동으로 생성 해 준다. Command간단한 ng command 몇가지를 소개하고, 그 아래에 hello world를 띄우기 위한 설명을 적겠다. help menu1ng --help 다른 CLI 명령어들에 비해 비교적 상세한 설명이 나온다. New Project1ng new &#123;project name&#125; Server1ng serve Component1ng generate component &#123;Component-Name&#125; 보통은 http://localhost:4200으로 접속 할 수 있다. Hello World오늘의 개발환경은 MAC OS 되겠다. Let’s just Follow me. 1234567$ ng new HelloWorldinstalling ng...Installing packages for tooling via npm.Installed packages for tooling via npm.Successfully initialized git.Project 'HelloWorld' successfully created. Installing packages for tooling via npm. 이 작업에 시간이 꽤 걸린다. 12$ cd HelloWorld/$ code . 한동안 Javascript Editor로는 Visual Studio Code(VS Code)를 사용할 예정이다.Bracket을 거쳐서 결국은 VS Code의 여러가지 장점(node.js Debugging, CLI, Extentions 등)에 힘입어 정착했다. code .을 입력하게 되면 해당 path를 기준으로 VS Code를 실행시킨다. 우하단에 terminal이 위치하며 단축키는 ctrl+` (backtick)이다. 12345678910111213141516$ ng serveYour global Angular CLI version (1.3.2) is greater than your localversion (1.3.1). The local Angular CLI version is used.To disable this warning use \"ng set --global warnings.versionMismatch=false\".** NG Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200 **Date: 2017-08-27T12:52:26.771ZHash: 2a33cad17c6b721c814bTime: 16822mschunk &#123;inline&#125; inline.bundle.js, inline.bundle.js.map (inline) 5.83 kB [entry] [rendered]chunk &#123;main&#125; main.bundle.js, main.bundle.js.map (main) 8.44 kB &#123;vendor&#125; [initial] [rendered]chunk &#123;polyfills&#125; polyfills.bundle.js, polyfills.bundle.js.map (polyfills) 209 kB &#123;inline&#125; [initial] [rendered]chunk &#123;styles&#125; styles.bundle.js, styles.bundle.js.map (styles) 11.3 kB &#123;inline&#125; [initial] [rendered]chunk &#123;vendor&#125; vendor.bundle.js, vendor.bundle.js.map (vendor) 2.27 MB [initial] [rendered]webpack: Compiled successfully. 위의 초록색 warning은 npm i -g typescript명령을 통해 global로 설치한 typescript가 ng tool의 dependency에 의해 설치된 typescript보다 버전이 높아서 그렇다.나중에 살포시 ng set --global warnings.versionMismatch=false를 입력 해 주면 된다. 짜잔. 현 버전의 angular/cli를 통해서 타이핑 몇개만 하고 만들어진 화면.하지만.. 이건 내가 Hello world 조차 입력한적이 없으므로 최소한 Hello World 정도는 입력 해 보자. src/app/app.module.ts12345678910import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; title = 'Rober\\'s app'; // &lt;- HERE&#125; ng new HelloWorld를 통해 skefolding 했을 때 우리 앱에 최초로 포함된 Component인 app.component.ts파일의 title을 수정한다. 그리고, templateUrl: &#39;./app.component.html&#39;을 보면 알 수 있듯, 연관된 HTML파일인 app.component.html파일을 수정한다. 12345678&lt;!--The content below is only a placeholder and can be replaced.--&gt;&lt;div style=\"text-align:center\"&gt; &lt;h1&gt; Welcome to &#123;&#123;title&#125;&#125;! &lt;/h1&gt; &lt;img width=\"300\" src=\"data:image/svg+xml;base64,.......\"&gt;&lt;/div&gt;&lt;h2&gt;This is my first App&lt;/h2&gt; &lt;!-- HERE --&gt; (&lt;img&gt; tag 안의 src 부분은 너무 길어서 짜름)&lt;/div&gt;아래에 원래 내용을 지우고, 원하는 문구를 넣고, browser를 refresh하면.. 어떻게 돌아가는지 자세한건 다음에 기회가 된다면(음음…..?! 요청하는 분들이 있으시다면..) 하도록 하고, 오늘은 이만. 대략적인 포인트는 아래와 같다. .angular-cli.json 에 main prop에 entry file이 있음 (default) main.ts 이 앱을 bootstrap bootstrap process가 Angular module 을 활성화(boost) 함 AppModule을 사용해서 앱을 활성화 시킬거고, src/app/app.module.ts 가 AppModule. AppModule이 어떤 컴포넌트가 top level component가 될지를 정함. (default: AppComponent) AppComponent는 app-root tag를 사용함","categories":[],"tags":[]},{"title":"Angular Routing","slug":"Angular-Routing","date":"2017-08-19T08:34:18.000Z","updated":"2017-08-19T16:04:46.000Z","comments":true,"path":"2017/08/19/Angular-Routing/","link":"","permalink":"http://khackskjs.github.io/2017/08/19/Angular-Routing/","excerpt":"","text":"Angular Routinganchor tag 사용일반적으로 Anchor tag(#) 를 이용해서 웹 페이지 내부 특정 위치로 이동을 정의 한다. 1&lt;a name=\"about\"&gt;&lt;h2&gt;About&lt;h2&gt;&lt;/a&gt; 이렇게 할 경우, http://server/#about 하게되면 해당 &lt;h2&gt; tag로 이동하게 된다. SPA(Single Page Application) 에서는 http://server/#/about과 같이 사용하며, 이를 hash-based rounting이라 한다. HTML5 Client-side RoutingHTML5에서 브라우저가 신규 요청없이 URL을 바꿀 수 있게 되었다.history.pushState javascript method를 통해서 navigation history 를 접근할 수 있다. HTML5 mode Routing older browser 는 지원하지 않음 server에서 HTML5 base routing을 지원해야 함 Angular 에서의 RoutingComponent와 path가 mapping 되도록 개발함 사용법1import &#123; RouterModule, Routes &#125; from '@angular/router';","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://khackskjs.github.io/tags/Angular/"},{"name":"Routing","slug":"Routing","permalink":"http://khackskjs.github.io/tags/Routing/"}]},{"title":"ASUS(RT-N56U) 간이 NAS 설정 (ext3)","slug":"ASUS-Temporary-NAS-External-HDD","date":"2017-08-13T12:59:55.000Z","updated":"2017-08-17T15:21:54.000Z","comments":true,"path":"2017/08/13/ASUS-Temporary-NAS-External-HDD/","link":"","permalink":"http://khackskjs.github.io/2017/08/13/ASUS-Temporary-NAS-External-HDD/","excerpt":"","text":"ASUS(RT-N56U) 간이 NAS 설정 (ext3)외장하드를 RT-N56U에 연결한 상태에서 Router의 설정 페이지에서 USB storage device is not responding 이란 문구가 뜨면서 Media Server도 설치를 할 수 없는 경우가 있다.이럴 경우 외장하드를 ext3로 format 한 후 설정하면 간이 NAS를 구성 할 수 있다. Router 정펌 + ext3 format 외장하드 조합으로 간이 NAS 구성은 완료 했으나, WIFI 신호가 불안정하고, 속도에 문제가 있는 경우가 발생해서 그냥 외장하드 연결을 제거했다. (2017.08.17)RT-N65U merlin firmware 는 없는것으로 보인다. 추후 openWRT firmware를 통해 삽질을 해보고 추가 하도록 하겠다. 외장하드 ext3 formatNTFS와 FAT32를 사용하면 약간 느리다는 이야기가 있다(NTFS는 특별히 더).그래서 ext3로 포멧하기로 했고, 이는 MAC에서는 brew 를 이용해서 ext3로 포멧 할 수 있다. brew 설치123456789101112$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"==&gt; This script will install:/usr/local/bin/brew/usr/local/share/doc/homebrew/usr/local/share/man/man1/brew.1/usr/local/share/zsh/site-functions/_brew/usr/local/etc/bash_completion.d/brew/usr/local/HomebrewPress RETURN to continue or any other key to abort==&gt; /usr/bin/sudo /bin/mkdir -p /Library/Caches/HomebrewPassword: install 명령어 입력 후 Press RETURN to continue or any other key to abort에서 Enter키를 눌러주고, Passwordㅔ서 관리자 password를 입력한다. 1HEAD is now at e1bab7e Merge pull request #3050 from Homebrew/revert-3046-double_formula_load_error 이전에 brew를 설치한적이 있다면 위의 문구를 보게 될것이고, 어쨋거나 기다리면 된다. (필자는 마지막이 해당 문구가 load_error로 끝나길래 오류 발생한줄 알았으나, terminal 상단의 제목표시줄이 바뀌는걸 보고 다운받는 중이란걸 알 수 있었다) 12$ brew install e2fsprogs==&gt; Installing dependencies for e2fsprogs: gettext diskutil 로 disk Identifier 얻기12345678910111213$ diskutil list/dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *750.2 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_HFS Robert's OS X 749.3 GB disk0s2 3: Apple_Boot Recovery HD 650.0 MB disk0s3/dev/disk1 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *250.1 GB disk1 1: EFI EFI 209.7 MB disk1s1 2: Apple_HFS Robert250G 249.7 GB disk1s2 본인이 사용할 HDD는 250G HDD로 ID는 disk1임을 알 수 있다. ext3 format1234$ sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext3 /dev/disk1Password:mke2fs 1.43.5 (04-Aug-2017)/dev/disk1: Resource busy while setting up superblock 위의 마지막 Resource 관련 메시지를 본다면, 해당 disk를 unmount 후 진행하면 된다. 123456$ diskutil unmount disk1s1Volume HDD_500 on disk1s1 unmounted$ sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext3 /dev/disk1mke2fs 1.43.5 (04-Aug-2017)... (중략)Writing superblocks and filesystem accounting information: done NAS 설정공유기 설정 페이지(default 192.168.1.1)에 접속해서 USB Application에서 필요한 것들(FTP, SAMBA 등)을 설치해서 사용하면 된다.관련 설명은 많이 존재하므로 생략. Reference site ASUS Router 모델별 Disks Compatibility List","categories":[],"tags":[{"name":"NAS","slug":"NAS","permalink":"http://khackskjs.github.io/tags/NAS/"},{"name":"ASUS","slug":"ASUS","permalink":"http://khackskjs.github.io/tags/ASUS/"},{"name":"RT-N56U","slug":"RT-N56U","permalink":"http://khackskjs.github.io/tags/RT-N56U/"},{"name":"ext3","slug":"ext3","permalink":"http://khackskjs.github.io/tags/ext3/"}]},{"title":"hexo, markdown syntax","slug":"hexo-markdown-syntax","date":"2017-06-30T14:13:04.000Z","updated":"2017-08-25T20:48:38.000Z","comments":true,"path":"2017/06/30/hexo-markdown-syntax/","link":"","permalink":"http://khackskjs.github.io/2017/06/30/hexo-markdown-syntax/","excerpt":"","text":"유용한 markdown 문법Code1234# 3 backticks'''[language] [title] [url] [link text]code snippet''' YouTubevideo_id: 유튜브에서 공유를 누른 후 나오는 URL 123&#123;% youtube video_id %&#125;# example&#123;% youtube q8GJh96pNu4 %&#125; Insert Postslug: 포스트 제목. 일자를 제외한 파일 제목.post_path: 해당 포스트의 URL 주소가 표시 됨post_link: 해당 포스트의 링크가 표시 됨 1234# Path&#123;% post_path slug %&#125;# Link&#123;% post_link slug [title] %&#125; Imagenew post 폴더별 설정 후 1234567![&#123;description&#125;](&#123;Image path&#125;)# or&#123;% asset_img Image_path [caption] %&#125;# example![this is my picture](Its_me.jpg)&#123;% asset_img IMG_3391.JPG hi %&#125;","categories":[{"name":"blog","slug":"blog","permalink":"http://khackskjs.github.io/categories/blog/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://khackskjs.github.io/tags/tip/"}]},{"title":"블로그 시작 환경 설정 (Hexo, github pages)","slug":"Setting-Hexo-github-pages","date":"2017-06-21T15:05:33.000Z","updated":"2017-07-28T16:34:36.000Z","comments":true,"path":"2017/06/22/Setting-Hexo-github-pages/","link":"","permalink":"http://khackskjs.github.io/2017/06/22/Setting-Hexo-github-pages/","excerpt":"","text":"순서는 크게 아래 3단계 hexo 설치 및 정적 페이지 생성 github repository &amp; Disqus ID 생성 github 연동 및 Disqus 설정 후 배포 Let’s just Follow me. npm이 설치 되어 있지 않으면 node.js를 설치하면 npm이 설치된다. 1. hexo 설치 및 정적 페이지 생성설치1&gt; npm install -g hexo-cli hexo 프로젝트 생성 및 dependency download123&gt; hexo init \"sVeloperBlog\"&gt; cd sVeloperBlog&gt; npm install 포스트 파일 생성123&gt; hexo new \"first post\"# or&gt; hexo n \"first post\" /source/_post/first-post.md 가 생성됨 예제 포스트first-post.md12345678910111213141516# First postIt's my first post!## Introduce myselfHello I'm Robert Kim.## more..My Hobby List- swimming- cycling- watching movie- etc. 포스트 확인123&gt; hexo server# or&gt; hexo s 일반적으로 http://localhost:4000 으로 확인 가능하며, command line output 으로 주소 확인 가능. 정적 페이지 생성123&gt; hexo generate# or&gt; hexo g /blog/public/에 실제 호스팅에 사용할 웹 페이지가 생성된다. Notice정적 페이지에 변경이 제대로 반영되지 않을 경우 hexo clean 후 hexo generate 2. github repository &amp; Disqus ID 생성github repositorygithub로 이동 후 가입 &amp; 로그인 한다. 우상단의 New repository를 선택한다. Repository name에 본인의 {github ID}.github.io 로 입력한 후 Create repository선택.(이미 이 블로그가 khackskjs.github.io를 사용하고 있어서 already exists) Disqus ID 생성댓글용 Disqus서비스를 사용하기 위해 사이트로 이동 후 가입하거나 지원하는 SNS 연동 이름, 이메일(인증 필요)을 이용해서 가입한다.이 블로그를 위해 khackskjs@gmail.com 계정은 이용중이므로, 다른 도메인 메일을 통해 이미지 캡쳐 코멘트를 이용 할 것이므로 위의 I want to comment on sites를 선택한다. Disqus의 구독 서비스를 이용하라는거 같은데 그냥 스킵하고, 우상단의 유저 아이콘을 선택한다. 계정설정 화면이 나오면 Edit Profile을 선택한다. 계정설정 화면에서 Acount탭에서 Username을 설정한다.disqus service를 통틀어 고유한 이름이어야 하며, 이를통해 hexo와 연동이 가능하다.(hexo _config.yml에서 disqus_shortname에 사용) 3. github 연동 및 Disqus 설정 후 배포git에 배포 해주는 플러긴을 설치한다. 1&gt; npm i hexo-deployer-git --save GitHub 계정 및 disqus_shortname 을 입력한다. ./_config.yml123456789# URLurl: http://&#123;github_id&#125;.github.io/# Deploymentdeploy: type: git repo: https://github.com/&#123;github_id&#125;/&#123;github_id&#125;.github.io branch: master# for Disqusdisqus_shortname: sveloper 이제 설정은 끝났고, 위에서 생성한 페이지 (hexo g)를 배포한다. 123&gt; hexo deploy# or&gt; hexo d github로 push가 되었을 것이다._config.yml파일의 url에 입력한 주소(ex: http://khackskjs.github.io/)로 이동하면 블로그가 보일 것이다.(입력은 http, 호스팅은 https) 기본적인 사용은 위의 포스팅을 따르면 문제 없을 것이다.(문제가 있다면 댓글 주시면 반영토록 하겠습니다) 좀 더 고급진(?) 사용을 원한다면 아래 링크들을 참조 하길 바란다. hexo, markdown syntax Tag Pluginshexo.io","categories":[{"name":"Blog","slug":"Blog","permalink":"http://khackskjs.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"http://khackskjs.github.io/categories/Blog/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://khackskjs.github.io/tags/Hexo/"},{"name":"Environment","slug":"Environment","permalink":"http://khackskjs.github.io/tags/Environment/"},{"name":"Follow me","slug":"Follow-me","permalink":"http://khackskjs.github.io/tags/Follow-me/"}]},{"title":"Ground Rule","slug":"Ground-Rule","date":"2017-06-21T14:49:01.000Z","updated":"2017-06-21T15:04:44.000Z","comments":true,"path":"2017/06/21/Ground-Rule/","link":"","permalink":"http://khackskjs.github.io/2017/06/21/Ground-Rule/","excerpt":"","text":"나의 Posting에 공통으로 적용 할 알아두면 좋을 규칙들 Shell Command 아래 소스코드에서 &gt;는 windows, $는 Linux 계열의 shell에 입력함을 의미한다. (간혹 필요할 경우, 입력 결과도 넣을 예정) 12345&gt; ipconfig$ ping 127.0.0.1PING 127.0.0.1 (127.0.0.1): 56 data bytes64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.090 ms Let’s just Follow me.아래와 같이 Caution으로 시작하는 주의 부분이 있지 않는이상 코드만 따라가도 문제 없음. Caution이 아래 부분은 요로쿵 조로쿵 해서 주의가 필요 하다.꼭 봐야 하는건 아니지만, 소스만 보고했다가 안되면 1순위로 보라는 의미 1console.warn(`Caution`);","categories":[{"name":"Blog","slug":"Blog","permalink":"http://khackskjs.github.io/categories/Blog/"}],"tags":[{"name":"ground rule","slug":"ground-rule","permalink":"http://khackskjs.github.io/tags/ground-rule/"}]},{"title":"블로그를 시작하며","slug":"starting-blog","date":"2017-06-21T12:44:18.000Z","updated":"2017-07-26T12:30:53.000Z","comments":true,"path":"2017/06/21/starting-blog/","link":"","permalink":"http://khackskjs.github.io/2017/06/21/starting-blog/","excerpt":"","text":"블로그. 일하다 필요에 의해 혹은 호기심으로 공부한 것들은 자주 접하지 않으면 얼마 지나지 않아 사라져 버린다. (나의 기억력은 RAM이라 불리우는…)그리고 대충 정리해서 두다보면 여기저기 분산되어 유실되거나, 추후 보면 알아 볼 수가 없다.이런 필요에 의해 뭔가 일원화된 정리방법이 필요했다.그럼에도 불구하고 이쁘게 혹은 보기 좋게 글을 작성하기가 쉽지 않을 것 같아 보여 블로그는 엄두를 내지 못하고 있었다. 궁하면 통하는법. 나의 요구는 다음과 같았다. source code 적용 가능 깔끔한 정리가 가능하되, 깔끔함을 위한 시간&amp;노력 대비 결과가 좋아야 함 Comment - 소통 오픈형 마침내 정리 할 방법을 찾았다. Markdown을 어느정도 익히고(정말 간단한 문법들), hexo를 이용하면 정적사이트를 생성 할 수 있다.그렇게 생성한 페이지는 github pages로 호스팅해서 블로그로 운영 할 수 있다.Comment는 정적 사이트가 아니므로 Disqus에 붙여 해결 할 수 있다. 뭔가 엄청 복잡하고 어려워 보이는데.. 실은 별거없이 **블로그 시작하기**를 따라하면 ‘나도 블로거 1일차’.(comment 붙이는데 너무 오래 걸렸다! 검색만 잘 하면 한글로 설명해놓은 블로거들이 있어 쉬움에도 불구하고..) 그럼 조금 더 쉽게 밥상에 숟가락을 얻기 위해 나의 포스팅에 적용 될 Ground Rule 을 알아 보자.","categories":[{"name":"Blog","slug":"Blog","permalink":"http://khackskjs.github.io/categories/Blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://khackskjs.github.io/tags/blog/"}]}]}